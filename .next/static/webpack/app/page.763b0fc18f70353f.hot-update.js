"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ChatInterface.tsx":
/*!******************************************!*\
  !*** ./src/components/ChatInterface.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChatInterface)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Menu_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Menu!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js\");\n/* harmony import */ var _Sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sidebar */ \"(app-pages-browser)/./src/components/Sidebar.tsx\");\n/* harmony import */ var _MessageList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MessageList */ \"(app-pages-browser)/./src/components/MessageList.tsx\");\n/* harmony import */ var _InputArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./InputArea */ \"(app-pages-browser)/./src/components/InputArea.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction ChatInterface() {\n    _s();\n    const [conversations, setConversations] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentConversationId, setCurrentConversationId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [sidebarOpen, setSidebarOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const isInitialLoad = react__WEBPACK_IMPORTED_MODULE_1___default().useRef(true);\n    const generateUUID = ()=>{\n        if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            const r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n    };\n    const fetchConversations = react__WEBPACK_IMPORTED_MODULE_1___default().useCallback({\n        \"ChatInterface.useCallback[fetchConversations]\": async (specificId)=>{\n            try {\n                const response = await fetch('https://n8n.srv974225.hstgr.cloud/webhook/get-conversations');\n                if (response.ok) {\n                    const text = await response.text();\n                    // Safe JSON parsing\n                    let data;\n                    try {\n                        if (text) data = JSON.parse(text);\n                    } catch (e) {\n                        console.warn('Invalid JSON from get-conversations', e);\n                        return;\n                    }\n                    if (data && data.success && Array.isArray(data.conversations)) {\n                        setConversations({\n                            \"ChatInterface.useCallback[fetchConversations]\": (prev)=>{\n                                // Create a map for quick lookup of existing conversations\n                                // We map by ID and Session ID to ensure we find matches even if ID changed\n                                const existingMap = new Map();\n                                prev.forEach({\n                                    \"ChatInterface.useCallback[fetchConversations]\": (c)=>{\n                                        existingMap.set(c.id, c);\n                                        if (c.session_id) existingMap.set(c.session_id, c);\n                                    }\n                                }[\"ChatInterface.useCallback[fetchConversations]\"]);\n                                const mapped = data.conversations.map({\n                                    \"ChatInterface.useCallback[fetchConversations].mapped\": (c)=>{\n                                        const backendId = c.id.toString();\n                                        // Try to find existing by ID or Session ID\n                                        const existing = existingMap.get(backendId) || (c.session_id ? existingMap.get(c.session_id) : null);\n                                        return {\n                                            id: backendId,\n                                            session_id: c.session_id,\n                                            title: c.title,\n                                            // Preserve existing messages if found, else empty\n                                            messages: existing ? existing.messages : [],\n                                            createdAt: new Date(c.created_at),\n                                            updatedAt: new Date(c.last_activity)\n                                        };\n                                    }\n                                }[\"ChatInterface.useCallback[fetchConversations].mapped\"]);\n                                // If current conversation was \"temporary\" (local ID) and now we have a real one from backend,\n                                // we might need to update currentConversationId if it got swapped. \n                                // But usually processMessage handles the ID swap. \n                                // If we are just listing, mapped list is safe.\n                                // CRITICAL FIX: Preserve the currently active conversation if it's not in the backend list yet.\n                                // This happens when creating a new chat; backend might be eventual consistent or slow to index,\n                                // causing the new chat to disappear from the sidebar/view.\n                                // Use specificId if provided (most accurate after a rename/save), otherwise fallback to current state\n                                const idToPreserve = specificId || currentConversationId;\n                                if (idToPreserve) {\n                                    const isPresent = mapped.some({\n                                        \"ChatInterface.useCallback[fetchConversations].isPresent\": (c)=>c.id === idToPreserve\n                                    }[\"ChatInterface.useCallback[fetchConversations].isPresent\"]);\n                                    if (!isPresent) {\n                                        // Try to find it in previous state\n                                        // Note: If specificId is new (real ID), it might not be in 'prev' with that ID if 'prev' still has Temp ID.\n                                        // BUT: setConversations update in processMessage typically happens BEFORE this fetch.\n                                        // So 'prev' here likely ALREADY has the swapped/real ID conversation inserted by processMessage.\n                                        const currentActive = prev.find({\n                                            \"ChatInterface.useCallback[fetchConversations].currentActive\": (c)=>c.id === idToPreserve\n                                        }[\"ChatInterface.useCallback[fetchConversations].currentActive\"]);\n                                        if (currentActive) {\n                                            // Prepend it to keep it visible/active\n                                            return [\n                                                currentActive,\n                                                ...mapped\n                                            ];\n                                        }\n                                    }\n                                }\n                                return mapped;\n                            }\n                        }[\"ChatInterface.useCallback[fetchConversations]\"]);\n                        // Only select first if absolutely nothing selected AND it is the initial load\n                        if (isInitialLoad.current) {\n                            if (!currentConversationId && data.conversations.length > 0) {\n                                setCurrentConversationId(data.conversations[0].id.toString());\n                            }\n                            isInitialLoad.current = false;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Failed to fetch conversations', error);\n                isInitialLoad.current = false; // Ensure we stop checking after first attempt even if failed\n            }\n        }\n    }[\"ChatInterface.useCallback[fetchConversations]\"], [\n        currentConversationId\n    ]); // Added currentConversationId as it is used inside setConversations logic check but mainly we need it stable. Actually setConversations updater doesn't need it. \n    // Wait, line 69 uses currentConversationId. So we need it in deps or use ref.\n    // Better: use setConversations callback fully or check currentConversationId ref. \n    // Simplify: just include it.\n    // Load conversations from backend on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatInterface.useEffect\": ()=>{\n            fetchConversations();\n        }\n    }[\"ChatInterface.useEffect\"], [\n        fetchConversations\n    ]);\n    // ... loadConversationHistory ... (unchanged)\n    // ... handleSendMessage ... (unchanged)\n    // ... processMessage ... (start)\n    // Load full history when a conversation is selected\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatInterface.useEffect\": ()=>{\n            if (currentConversationId) {\n                const conversation = conversations.find({\n                    \"ChatInterface.useEffect.conversation\": (c)=>c.id === currentConversationId\n                }[\"ChatInterface.useEffect.conversation\"]);\n                if (conversation && conversation.session_id && conversation.messages.length === 0) {\n                    loadConversationHistory(conversation.session_id, currentConversationId);\n                }\n            }\n        }\n    }[\"ChatInterface.useEffect\"], [\n        currentConversationId,\n        conversations\n    ]); // Added conversations to dependency array to react to updates\n    const loadConversationHistory = async (sessionId, conversationId)=>{\n        setIsLoading(true);\n        try {\n            const response = await fetch(\"https://n8n.srv974225.hstgr.cloud/webhook/98b211e8-1325-4867-a937-9bdaa0f140d2/get-conversation/\".concat(sessionId));\n            if (response.ok) {\n                const text = await response.text();\n                if (!text) return; // Silent return if empty\n                let data;\n                try {\n                    data = JSON.parse(text);\n                } catch (e) {\n                    console.warn('Invalid JSON from get-conversation', e);\n                    return;\n                }\n                if (data.success && Array.isArray(data.messages)) {\n                    // Map backend messages to frontend format\n                    const mappedMessages = data.messages.map((msg, index)=>{\n                        let messageData = null;\n                        // Check if this message has special action/data\n                        // Relaxed check: if action is search OR it has files populated\n                        if (msg.action === 'semantic_search_results' || msg.files && msg.files.length > 0) {\n                            var _msg_files;\n                            messageData = {\n                                type: 'search',\n                                success: true,\n                                found: true,\n                                count: msg.results_count || ((_msg_files = msg.files) === null || _msg_files === void 0 ? void 0 : _msg_files.length) || 0,\n                                message: msg.content,\n                                avg_similarity: msg.avg_similarity || 0,\n                                files: msg.files || [],\n                                searchCriteria: msg.search_criteria\n                            };\n                        } else if (msg.action === 'document_generated' || msg.document_content && msg.file_info) {\n                            var _msg_file_info, _msg_file_info1;\n                            messageData = {\n                                type: 'document_generation',\n                                action: 'document_generation',\n                                success: true,\n                                message: msg.content,\n                                document: {\n                                    title: ((_msg_file_info = msg.file_info) === null || _msg_file_info === void 0 ? void 0 : _msg_file_info.name) || \"Generated Document\",\n                                    content: msg.document_content,\n                                    type: ((_msg_file_info1 = msg.file_info) === null || _msg_file_info1 === void 0 ? void 0 : _msg_file_info1.type) || \"document\"\n                                }\n                            };\n                        }\n                        return {\n                            id: \"hist-\".concat(index, \"-\").concat(Date.now()),\n                            role: msg.role === 'assistant' ? 'ai' : 'user',\n                            content: msg.content,\n                            timestamp: new Date(msg.timestamp),\n                            files: [],\n                            data: messageData\n                        };\n                    });\n                    setConversations((prev)=>prev.map((conv)=>{\n                            if (conv.id === conversationId) {\n                                return {\n                                    ...conv,\n                                    messages: mappedMessages\n                                };\n                            }\n                            return conv;\n                        }));\n                }\n            }\n        } catch (error) {\n            console.error('Failed to load history', error);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const getCurrentMessages = ()=>{\n        const conversation = conversations.find((c)=>c.id === currentConversationId);\n        return conversation ? conversation.messages : [];\n    };\n    const createNewConversation = ()=>{\n        // For new conversation, we just reset the view. \n        // Real creation happens on first message.\n        // We can temporarily add a placeholder in state or just null the ID.\n        setCurrentConversationId(null);\n    };\n    const handleSendMessage = async (content, files)=>{\n        let activeId = currentConversationId;\n        let activeSessionId = undefined;\n        if (!activeId) {\n            const newId = Date.now().toString();\n            // Generate a proper session ID immediately for the new conversation\n            activeSessionId = \"session-\".concat(generateUUID());\n            const newConv = {\n                id: newId,\n                session_id: activeSessionId,\n                title: content.slice(0, 30) || 'New Chat',\n                messages: [],\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n            setConversations((prev)=>[\n                    newConv,\n                    ...prev\n                ]);\n            activeId = newId;\n            setCurrentConversationId(newId);\n        }\n        processMessage(activeId, content, files, activeSessionId);\n    };\n    const processMessage = async (conversationId, content, files, sessionIdOverride)=>{\n        // Create user message\n        const userMessage = {\n            id: Date.now().toString(),\n            role: 'user',\n            content,\n            timestamp: new Date(),\n            files\n        };\n        // Update conversation with user message\n        setConversations((prev)=>prev.map((conv)=>{\n                if (conv.id === conversationId) {\n                    return {\n                        ...conv,\n                        messages: [\n                            ...conv.messages,\n                            userMessage\n                        ],\n                        title: conv.messages.length === 0 ? content.slice(0, 30) + (content.length > 30 ? '...' : '') : conv.title,\n                        updatedAt: new Date()\n                    };\n                }\n                return conv;\n            }));\n        setIsLoading(true);\n        let resultItem = null; // eslint-disable-line @typescript-eslint/no-explicit-any\n        try {\n            var _resultItem_conversation;\n            const formData = new FormData();\n            files.forEach((fileAttachment)=>{\n                formData.append('files', fileAttachment.file);\n            });\n            formData.append('query', content);\n            const currentConv = conversations.find((c)=>c.id === conversationId);\n            // Use the override if provided (for new chats where state might not be updated yet), otherwise fallback to state\n            const sessionIdToSend = sessionIdOverride || (currentConv ? currentConv.session_id : undefined);\n            if (sessionIdToSend) {\n                formData.append('session_id', sessionIdToSend);\n                // Also Send user_id if needed, defaulted\n                formData.append('user_id', 'anonymous');\n            }\n            const response = await fetch('https://n8n.srv974225.hstgr.cloud/webhook/auto-save-files', {\n                method: 'POST',\n                body: formData\n            });\n            if (!response.ok) {\n                throw new Error(\"API Error: \".concat(response.statusText));\n            }\n            const text = await response.text();\n            let data = {}; // eslint-disable-line @typescript-eslint/no-explicit-any\n            try {\n                if (text) data = JSON.parse(text);\n            } catch (e) {\n                console.warn(\"Empty or invalid JSON response from N8N\", e);\n            }\n            // Determine response type and structure\n            let aiContent = \"Processed successfully.\";\n            let messageData = null;\n            // lifted to outer scope for finally block\n            // Normalize data: if array, use first item; else use data object\n            resultItem = Array.isArray(data) ? data[0] : data;\n            if (resultItem) {\n                // Check for Search Response (Vector search often returns searchType='vector' and files array)\n                if (resultItem.searchType === 'vector' || resultItem.files && resultItem.files.length > 0) {\n                    messageData = {\n                        type: 'search',\n                        ...resultItem,\n                        files: resultItem.files || []\n                    };\n                    aiContent = resultItem.message || \"Here are the files I found matching your request.\";\n                } else if (resultItem.action === 'document_generation' || resultItem.document) {\n                    messageData = {\n                        type: 'document_generation',\n                        ...resultItem\n                    };\n                    aiContent = resultItem.message || \"I have generated the document for you.\";\n                } else if (resultItem.alreadyProcessed) {\n                    messageData = {\n                        type: 'upload',\n                        ...resultItem\n                    };\n                    aiContent = resultItem.message || \"This file has already been processed.\";\n                } else if (resultItem.success && resultItem.file) {\n                    messageData = {\n                        type: 'upload',\n                        ...resultItem\n                    };\n                    aiContent = resultItem.message || \"File uploaded successfully.\";\n                } else if (resultItem.message) {\n                    aiContent = resultItem.message;\n                }\n            }\n            if (!text && !resultItem) {\n                aiContent = \"Request received, but no response content was returned.\";\n            }\n            // Update session_id if returned\n            if (resultItem && (resultItem.sessionId || ((_resultItem_conversation = resultItem.conversation) === null || _resultItem_conversation === void 0 ? void 0 : _resultItem_conversation.session_id))) {\n                var _resultItem_conversation1, _resultItem_conversation2;\n                const newSessionId = resultItem.sessionId || ((_resultItem_conversation1 = resultItem.conversation) === null || _resultItem_conversation1 === void 0 ? void 0 : _resultItem_conversation1.session_id);\n                const newId = ((_resultItem_conversation2 = resultItem.conversation) === null || _resultItem_conversation2 === void 0 ? void 0 : _resultItem_conversation2.id) ? resultItem.conversation.id.toString() : null;\n                setConversations((prev)=>prev.map((conv)=>{\n                        if (conv.id === conversationId) {\n                            return {\n                                ...conv,\n                                session_id: newSessionId,\n                                id: newId || conv.id\n                            };\n                        }\n                        return conv;\n                    }));\n                if (newId && conversationId !== newId) {\n                    setCurrentConversationId((prev)=>prev === conversationId ? newId : prev);\n                }\n            }\n            const aiMessage = {\n                id: (Date.now() + 1).toString(),\n                role: 'ai',\n                content: aiContent,\n                timestamp: new Date(),\n                data: messageData\n            };\n            setConversations((prev)=>prev.map((conv)=>{\n                    var _resultItem_conversation;\n                    // Use the potentially new ID if we just updated it, OR logic to sync\n                    // Since state update is async, 'conv.id' in this cycle might presumably still be old ID if mapped immediately?\n                    // No, we are inside a new SetState.\n                    // To be safe, we match either ID.\n                    const targetId = (resultItem === null || resultItem === void 0 ? void 0 : (_resultItem_conversation = resultItem.conversation) === null || _resultItem_conversation === void 0 ? void 0 : _resultItem_conversation.id) && conversationId !== resultItem.conversation.id.toString() ? resultItem.conversation.id.toString() : conversationId;\n                    if (conv.id === targetId || conv.id === conversationId) {\n                        return {\n                            ...conv,\n                            messages: [\n                                ...conv.messages,\n                                aiMessage\n                            ],\n                            updatedAt: new Date()\n                        };\n                    }\n                    return conv;\n                }));\n        } catch (error) {\n            console.error('Error sending message:', error);\n            const errorMessage = {\n                id: (Date.now() + 1).toString(),\n                role: 'ai',\n                content: \"Sorry, I encountered an error communicating with the server. Please try again.\",\n                timestamp: new Date()\n            };\n            setConversations((prev)=>prev.map((conv)=>{\n                    if (conv.id === conversationId) {\n                        return {\n                            ...conv,\n                            messages: [\n                                ...conv.messages,\n                                errorMessage\n                            ],\n                            updatedAt: new Date()\n                        };\n                    }\n                    return conv;\n                }));\n        } finally{\n            var _resultItem_conversation3;\n            setIsLoading(false);\n            // Refresh conversation list to update titles/timestamps\n            // Pass the correct ID (new real one or existing one) to ensure it is preserved if not yet in list\n            const finalId = (resultItem === null || resultItem === void 0 ? void 0 : (_resultItem_conversation3 = resultItem.conversation) === null || _resultItem_conversation3 === void 0 ? void 0 : _resultItem_conversation3.id) && conversationId !== resultItem.conversation.id.toString() ? resultItem.conversation.id.toString() : conversationId;\n            fetchConversations(finalId);\n        }\n    };\n    const handleRenameConversation = async (id, newTitle)=>{\n        // Optimistic update\n        setConversations((prev)=>prev.map((c)=>c.id === id ? {\n                    ...c,\n                    title: newTitle\n                } : c));\n        const conversation = conversations.find((c)=>c.id === id);\n        if (conversation && conversation.session_id) {\n            try {\n                const response = await fetch(\"https://n8n.srv974225.hstgr.cloud/webhook/98b211e8-1325-4867-a937-9bdaa0f140d2/rename-conversation/\".concat(conversation.session_id), {\n                    method: 'PATCH',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        title: newTitle\n                    })\n                });\n                const data = await response.json();\n                if (data.success) {\n                    alert('Conversation renamed successfully');\n                } else {\n                    alert(\"Error: \".concat(data.error || 'Failed to rename conversation'));\n                // Ideally revert optimistic update here\n                }\n            } catch (error) {\n                console.error('Failed to rename conversation', error);\n                alert('Error: Failed to rename conversation. Please check your connection.');\n            }\n        }\n    };\n    const handleDeleteConversation = async (id, e)=>{\n        e.stopPropagation();\n        if (!confirm('Are you sure you want to delete this conversation?')) return;\n        const conversation = conversations.find((c)=>c.id === id);\n        // Optimistic delete\n        setConversations((prev)=>prev.filter((c)=>c.id !== id));\n        if (currentConversationId === id) {\n            setCurrentConversationId(null);\n        }\n        if (conversation && conversation.session_id) {\n            try {\n                const response = await fetch(\"https://n8n.srv974225.hstgr.cloud/webhook/98b211e8-1325-4867-a937-9bdaa0f140d2/delete-conversation/\".concat(conversation.session_id), {\n                    method: 'DELETE'\n                });\n                const data = await response.json();\n                if (data.success) {\n                    alert(data.message || 'Conversation deleted');\n                } else {\n                    alert(\"Error: \".concat(data.error || 'Failed to delete conversation'));\n                // Should revert state if failed\n                }\n            } catch (error) {\n                console.error('Failed to delete conversation', error);\n                alert('Error: Failed to delete conversation. Please check your connection.');\n            }\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex h-screen bg-[var(--background)] text-[var(--foreground)] overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Sidebar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                conversations: conversations,\n                currentConversationId: currentConversationId,\n                onSelectConversation: setCurrentConversationId,\n                onNewChat: createNewConversation,\n                onRenameConversation: handleRenameConversation,\n                onDeleteConversation: handleDeleteConversation,\n                isOpen: sidebarOpen,\n                onClose: ()=>setSidebarOpen(false)\n            }, void 0, false, {\n                fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                lineNumber: 505,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 flex flex-col h-full relative w-full\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"md:hidden flex items-center p-4 border-b border-[var(--border-color)] bg-[var(--background)]\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSidebarOpen(true),\n                                className: \"p-2 -ml-2 text-gray-400 hover:text-white\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"w-6 h-6\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                                    lineNumber: 523,\n                                    columnNumber: 25\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                                lineNumber: 519,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"ml-2 font-semibold\",\n                                children: \"AI Assistant\"\n                            }, void 0, false, {\n                                fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                                lineNumber: 525,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                        lineNumber: 518,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MessageList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        messages: getCurrentMessages(),\n                        isLoading: isLoading\n                    }, void 0, false, {\n                        fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                        lineNumber: 529,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_InputArea__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        onSendMessage: handleSendMessage,\n                        disabled: isLoading\n                    }, void 0, false, {\n                        fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                        lineNumber: 535,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n                lineNumber: 516,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/tarek/Desktop/my website/ChatAI/src/components/ChatInterface.tsx\",\n        lineNumber: 504,\n        columnNumber: 9\n    }, this);\n}\n_s(ChatInterface, \"B7j6bMqgP9AfJ+zbkDvLpFrl2Bk=\");\n_c = ChatInterface;\nvar _c;\n$RefreshReg$(_c, \"ChatInterface\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXRJbnRlcmZhY2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDZjtBQUVKO0FBQ1E7QUFDSjtBQUVyQixTQUFTTzs7SUFDcEIsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR1IsK0NBQVFBLENBQWlCLEVBQUU7SUFDckUsTUFBTSxDQUFDUyx1QkFBdUJDLHlCQUF5QixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDbEYsTUFBTSxDQUFDVyxhQUFhQyxlQUFlLEdBQUdaLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2EsV0FBV0MsYUFBYSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNZSxnQkFBZ0JoQixtREFBWSxDQUFDO0lBRW5DLE1BQU1rQixlQUFlO1FBQ2pCLElBQUksT0FBT0MsV0FBVyxlQUFlQSxPQUFPQyxVQUFVLEVBQUU7WUFDcEQsT0FBT0QsT0FBT0MsVUFBVTtRQUM1QjtRQUNBLE9BQU8sdUNBQXVDQyxPQUFPLENBQUMsU0FBUyxTQUFVQyxDQUFDO1lBQ3RFLE1BQU1DLElBQUlDLEtBQUtDLE1BQU0sS0FBSyxLQUFLLEdBQUdDLElBQUlKLEtBQUssTUFBTUMsSUFBS0EsSUFBSSxNQUFNO1lBQ2hFLE9BQU9HLEVBQUVDLFFBQVEsQ0FBQztRQUN0QjtJQUNKO0lBRUEsTUFBTUMscUJBQXFCNUIsd0RBQWlCO3lEQUFDLE9BQU84QjtZQUNoRCxJQUFJO2dCQUNBLE1BQU1DLFdBQVcsTUFBTUMsTUFBTTtnQkFDN0IsSUFBSUQsU0FBU0UsRUFBRSxFQUFFO29CQUNiLE1BQU1DLE9BQU8sTUFBTUgsU0FBU0csSUFBSTtvQkFDaEMsb0JBQW9CO29CQUNwQixJQUFJQztvQkFDSixJQUFJO3dCQUNBLElBQUlELE1BQU1DLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0g7b0JBQ2hDLEVBQUUsT0FBT0ksR0FBRzt3QkFDUkMsUUFBUUMsSUFBSSxDQUFDLHVDQUF1Q0Y7d0JB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REFBQ0s7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUN6SSxnREFBT0E7Z0JBQ0pJLGVBQWVBO2dCQUNmRSx1QkFBdUJBO2dCQUN2Qm9JLHNCQUFzQm5JO2dCQUN0Qm9JLFdBQVc1QztnQkFDWDZDLHNCQUFzQmQ7Z0JBQ3RCZSxzQkFBc0JUO2dCQUN0QlUsUUFBUXRJO2dCQUNSdUksU0FBUyxJQUFNdEksZUFBZTs7Ozs7OzBCQUdsQyw4REFBQytIO2dCQUFJQyxXQUFVOztrQ0FFWCw4REFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNYLDhEQUFDTztnQ0FDR0MsU0FBUyxJQUFNeEksZUFBZTtnQ0FDOUJnSSxXQUFVOzBDQUVWLDRFQUFDMUksZ0ZBQUlBO29DQUFDMEksV0FBVTs7Ozs7Ozs7Ozs7MENBRXBCLDhEQUFDUztnQ0FBS1QsV0FBVTswQ0FBcUI7Ozs7Ozs7Ozs7OztrQ0FJekMsOERBQUN4SSxvREFBV0E7d0JBQ1JvRCxVQUFVeUM7d0JBQ1ZwRixXQUFXQTs7Ozs7O2tDQUlmLDhEQUFDUixrREFBU0E7d0JBQ05pSixlQUFlbkQ7d0JBQ2ZvRCxVQUFVMUk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUs5QjtHQXBoQndCUDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RhcmVrL0Rlc2t0b3AvbXkgd2Vic2l0ZS9DaGF0QUkvc3JjL2NvbXBvbmVudHMvQ2hhdEludGVyZmFjZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1lbnUgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuaW1wb3J0IHsgTWVzc2FnZSwgQ29udmVyc2F0aW9uLCBGaWxlQXR0YWNobWVudCwgQmFja2VuZENvbnZlcnNhdGlvbiwgQmFja2VuZE1lc3NhZ2UgfSBmcm9tICdAL3R5cGVzL3R5cGVzJztcbmltcG9ydCBTaWRlYmFyIGZyb20gJy4vU2lkZWJhcic7XG5pbXBvcnQgTWVzc2FnZUxpc3QgZnJvbSAnLi9NZXNzYWdlTGlzdCc7XG5pbXBvcnQgSW5wdXRBcmVhIGZyb20gJy4vSW5wdXRBcmVhJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hhdEludGVyZmFjZSgpIHtcbiAgICBjb25zdCBbY29udmVyc2F0aW9ucywgc2V0Q29udmVyc2F0aW9uc10gPSB1c2VTdGF0ZTxDb252ZXJzYXRpb25bXT4oW10pO1xuICAgIGNvbnN0IFtjdXJyZW50Q29udmVyc2F0aW9uSWQsIHNldEN1cnJlbnRDb252ZXJzYXRpb25JZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbc2lkZWJhck9wZW4sIHNldFNpZGViYXJPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGlzSW5pdGlhbExvYWQgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG5cbiAgICBjb25zdCBnZW5lcmF0ZVVVSUQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmV0Y2hDb252ZXJzYXRpb25zID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKHNwZWNpZmljSWQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vbjhuLnNydjk3NDIyNS5oc3Rnci5jbG91ZC93ZWJob29rL2dldC1jb252ZXJzYXRpb25zJyk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIFNhZmUgSlNPTiBwYXJzaW5nXG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpIGRhdGEgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEpTT04gZnJvbSBnZXQtY29udmVyc2F0aW9ucycsIGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5zdWNjZXNzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5jb252ZXJzYXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb252ZXJzYXRpb25zKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIGZvciBxdWljayBsb29rdXAgb2YgZXhpc3RpbmcgY29udmVyc2F0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWFwIGJ5IElEIGFuZCBTZXNzaW9uIElEIHRvIGVuc3VyZSB3ZSBmaW5kIG1hdGNoZXMgZXZlbiBpZiBJRCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ01hcC5zZXQoYy5pZCwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc2Vzc2lvbl9pZCkgZXhpc3RpbmdNYXAuc2V0KGMuc2Vzc2lvbl9pZCwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkOiBDb252ZXJzYXRpb25bXSA9IGRhdGEuY29udmVyc2F0aW9ucy5tYXAoKGM6IEJhY2tlbmRDb252ZXJzYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrZW5kSWQgPSBjLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgZXhpc3RpbmcgYnkgSUQgb3IgU2Vzc2lvbiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gZXhpc3RpbmdNYXAuZ2V0KGJhY2tlbmRJZCkgfHwgKGMuc2Vzc2lvbl9pZCA/IGV4aXN0aW5nTWFwLmdldChjLnNlc3Npb25faWQpIDogbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYmFja2VuZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uX2lkOiBjLnNlc3Npb25faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBjLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBleGlzdGluZyBtZXNzYWdlcyBpZiBmb3VuZCwgZWxzZSBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogZXhpc3RpbmcgPyBleGlzdGluZy5tZXNzYWdlcyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGMuY3JlYXRlZF9hdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoYy5sYXN0X2FjdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY3VycmVudCBjb252ZXJzYXRpb24gd2FzIFwidGVtcG9yYXJ5XCIgKGxvY2FsIElEKSBhbmQgbm93IHdlIGhhdmUgYSByZWFsIG9uZSBmcm9tIGJhY2tlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBuZWVkIHRvIHVwZGF0ZSBjdXJyZW50Q29udmVyc2F0aW9uSWQgaWYgaXQgZ290IHN3YXBwZWQuIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IHVzdWFsbHkgcHJvY2Vzc01lc3NhZ2UgaGFuZGxlcyB0aGUgSUQgc3dhcC4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUganVzdCBsaXN0aW5nLCBtYXBwZWQgbGlzdCBpcyBzYWZlLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IFByZXNlcnZlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbnZlcnNhdGlvbiBpZiBpdCdzIG5vdCBpbiB0aGUgYmFja2VuZCBsaXN0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIGNyZWF0aW5nIGEgbmV3IGNoYXQ7IGJhY2tlbmQgbWlnaHQgYmUgZXZlbnR1YWwgY29uc2lzdGVudCBvciBzbG93IHRvIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2F1c2luZyB0aGUgbmV3IGNoYXQgdG8gZGlzYXBwZWFyIGZyb20gdGhlIHNpZGViYXIvdmlldy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHNwZWNpZmljSWQgaWYgcHJvdmlkZWQgKG1vc3QgYWNjdXJhdGUgYWZ0ZXIgYSByZW5hbWUvc2F2ZSksIG90aGVyd2lzZSBmYWxsYmFjayB0byBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZFRvUHJlc2VydmUgPSBzcGVjaWZpY0lkIHx8IGN1cnJlbnRDb252ZXJzYXRpb25JZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IG1hcHBlZC5zb21lKGMgPT4gYy5pZCA9PT0gaWRUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBpdCBpbiBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBJZiBzcGVjaWZpY0lkIGlzIG5ldyAocmVhbCBJRCksIGl0IG1pZ2h0IG5vdCBiZSBpbiAncHJldicgd2l0aCB0aGF0IElEIGlmICdwcmV2JyBzdGlsbCBoYXMgVGVtcCBJRC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQlVUOiBzZXRDb252ZXJzYXRpb25zIHVwZGF0ZSBpbiBwcm9jZXNzTWVzc2FnZSB0eXBpY2FsbHkgaGFwcGVucyBCRUZPUkUgdGhpcyBmZXRjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28gJ3ByZXYnIGhlcmUgbGlrZWx5IEFMUkVBRFkgaGFzIHRoZSBzd2FwcGVkL3JlYWwgSUQgY29udmVyc2F0aW9uIGluc2VydGVkIGJ5IHByb2Nlc3NNZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gcHJldi5maW5kKGMgPT4gYy5pZCA9PT0gaWRUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgaXQgdG8ga2VlcCBpdCB2aXNpYmxlL2FjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjdXJyZW50QWN0aXZlLCAuLi5tYXBwZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNlbGVjdCBmaXJzdCBpZiBhYnNvbHV0ZWx5IG5vdGhpbmcgc2VsZWN0ZWQgQU5EIGl0IGlzIHRoZSBpbml0aWFsIGxvYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udmVyc2F0aW9uSWQgJiYgZGF0YS5jb252ZXJzYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q29udmVyc2F0aW9uSWQoZGF0YS5jb252ZXJzYXRpb25zWzBdLmlkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbml0aWFsTG9hZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY29udmVyc2F0aW9ucycsIGVycm9yKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbExvYWQuY3VycmVudCA9IGZhbHNlOyAvLyBFbnN1cmUgd2Ugc3RvcCBjaGVja2luZyBhZnRlciBmaXJzdCBhdHRlbXB0IGV2ZW4gaWYgZmFpbGVkXG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudENvbnZlcnNhdGlvbklkXSk7IC8vIEFkZGVkIGN1cnJlbnRDb252ZXJzYXRpb25JZCBhcyBpdCBpcyB1c2VkIGluc2lkZSBzZXRDb252ZXJzYXRpb25zIGxvZ2ljIGNoZWNrIGJ1dCBtYWlubHkgd2UgbmVlZCBpdCBzdGFibGUuIEFjdHVhbGx5IHNldENvbnZlcnNhdGlvbnMgdXBkYXRlciBkb2Vzbid0IG5lZWQgaXQuIFxuICAgIC8vIFdhaXQsIGxpbmUgNjkgdXNlcyBjdXJyZW50Q29udmVyc2F0aW9uSWQuIFNvIHdlIG5lZWQgaXQgaW4gZGVwcyBvciB1c2UgcmVmLlxuICAgIC8vIEJldHRlcjogdXNlIHNldENvbnZlcnNhdGlvbnMgY2FsbGJhY2sgZnVsbHkgb3IgY2hlY2sgY3VycmVudENvbnZlcnNhdGlvbklkIHJlZi4gXG4gICAgLy8gU2ltcGxpZnk6IGp1c3QgaW5jbHVkZSBpdC5cblxuICAgIC8vIExvYWQgY29udmVyc2F0aW9ucyBmcm9tIGJhY2tlbmQgb24gbW91bnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBmZXRjaENvbnZlcnNhdGlvbnMoKTtcbiAgICB9LCBbZmV0Y2hDb252ZXJzYXRpb25zXSk7XG5cbiAgICAvLyAuLi4gbG9hZENvbnZlcnNhdGlvbkhpc3RvcnkgLi4uICh1bmNoYW5nZWQpXG5cbiAgICAvLyAuLi4gaGFuZGxlU2VuZE1lc3NhZ2UgLi4uICh1bmNoYW5nZWQpXG5cbiAgICAvLyAuLi4gcHJvY2Vzc01lc3NhZ2UgLi4uIChzdGFydClcblxuXG5cbiAgICAvLyBMb2FkIGZ1bGwgaGlzdG9yeSB3aGVuIGEgY29udmVyc2F0aW9uIGlzIHNlbGVjdGVkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRDb252ZXJzYXRpb25JZCkge1xuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gY29udmVyc2F0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbnZlcnNhdGlvbklkKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJzYXRpb24gJiYgY29udmVyc2F0aW9uLnNlc3Npb25faWQgJiYgY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvYWRDb252ZXJzYXRpb25IaXN0b3J5KGNvbnZlcnNhdGlvbi5zZXNzaW9uX2lkLCBjdXJyZW50Q29udmVyc2F0aW9uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRDb252ZXJzYXRpb25JZCwgY29udmVyc2F0aW9uc10pOyAvLyBBZGRlZCBjb252ZXJzYXRpb25zIHRvIGRlcGVuZGVuY3kgYXJyYXkgdG8gcmVhY3QgdG8gdXBkYXRlc1xuXG4gICAgY29uc3QgbG9hZENvbnZlcnNhdGlvbkhpc3RvcnkgPSBhc3luYyAoc2Vzc2lvbklkOiBzdHJpbmcsIGNvbnZlcnNhdGlvbklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9uOG4uc3J2OTc0MjI1LmhzdGdyLmNsb3VkL3dlYmhvb2svOThiMjExZTgtMTMyNS00ODY3LWE5MzctOWJkYWEwZjE0MGQyL2dldC1jb252ZXJzYXRpb24vJHtzZXNzaW9uSWR9YCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGV4dCkgcmV0dXJuOyAvLyBTaWxlbnQgcmV0dXJuIGlmIGVtcHR5XG5cbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBKU09OIGZyb20gZ2V0LWNvbnZlcnNhdGlvbicsIGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBBcnJheS5pc0FycmF5KGRhdGEubWVzc2FnZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcCBiYWNrZW5kIG1lc3NhZ2VzIHRvIGZyb250ZW5kIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRNZXNzYWdlczogTWVzc2FnZVtdID0gZGF0YS5tZXNzYWdlcy5tYXAoKG1zZzogQmFja2VuZE1lc3NhZ2UsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgbWVzc2FnZSBoYXMgc3BlY2lhbCBhY3Rpb24vZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsYXhlZCBjaGVjazogaWYgYWN0aW9uIGlzIHNlYXJjaCBPUiBpdCBoYXMgZmlsZXMgcG9wdWxhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ3NlbWFudGljX3NlYXJjaF9yZXN1bHRzJyB8fCAobXNnLmZpbGVzICYmIG1zZy5maWxlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VhcmNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBtc2cucmVzdWx0c19jb3VudCB8fCBtc2cuZmlsZXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2cuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnX3NpbWlsYXJpdHk6IG1zZy5hdmdfc2ltaWxhcml0eSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlczogbXNnLmZpbGVzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDcml0ZXJpYTogbXNnLnNlYXJjaF9jcml0ZXJpYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1zZy5hY3Rpb24gPT09ICdkb2N1bWVudF9nZW5lcmF0ZWQnIHx8IChtc2cuZG9jdW1lbnRfY29udGVudCAmJiBtc2cuZmlsZV9pbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG9jdW1lbnRfZ2VuZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2RvY3VtZW50X2dlbmVyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2cuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBtc2cuZmlsZV9pbmZvPy5uYW1lIHx8IFwiR2VuZXJhdGVkIERvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBtc2cuZG9jdW1lbnRfY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1zZy5maWxlX2luZm8/LnR5cGUgfHwgXCJkb2N1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIG90aGVyIGZpZWxkcyBpZiBuZWVkZWQsIGUuZy4gZnJvbSBmaWxlX2luZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGBoaXN0LSR7aW5kZXh9LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IG1zZy5yb2xlID09PSAnYXNzaXN0YW50JyA/ICdhaScgOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbXNnLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShtc2cudGltZXN0YW1wKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlczogW10sIC8vIEZpbGVzIGluIGhpc3RvcnkgdXN1YWxseSBoYW5kbGVkIHZpYSB0aGUgbWVzc2FnZSBkYXRhIGZvciBzZWFyY2ggcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDb252ZXJzYXRpb25zKHByZXYgPT4gcHJldi5tYXAoY29udiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udi5pZCA9PT0gY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jb252LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogbWFwcGVkTWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnY7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBoaXN0b3J5JywgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBnZXRDdXJyZW50TWVzc2FnZXMgPSAoKTogTWVzc2FnZVtdID0+IHtcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gY29udmVyc2F0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbnZlcnNhdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbiA/IGNvbnZlcnNhdGlvbi5tZXNzYWdlcyA6IFtdO1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVOZXdDb252ZXJzYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIC8vIEZvciBuZXcgY29udmVyc2F0aW9uLCB3ZSBqdXN0IHJlc2V0IHRoZSB2aWV3LiBcbiAgICAgICAgLy8gUmVhbCBjcmVhdGlvbiBoYXBwZW5zIG9uIGZpcnN0IG1lc3NhZ2UuXG4gICAgICAgIC8vIFdlIGNhbiB0ZW1wb3JhcmlseSBhZGQgYSBwbGFjZWhvbGRlciBpbiBzdGF0ZSBvciBqdXN0IG51bGwgdGhlIElELlxuICAgICAgICBzZXRDdXJyZW50Q29udmVyc2F0aW9uSWQobnVsbCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgZmlsZXM6IEZpbGVBdHRhY2htZW50W10pID0+IHtcbiAgICAgICAgbGV0IGFjdGl2ZUlkID0gY3VycmVudENvbnZlcnNhdGlvbklkO1xuICAgICAgICBsZXQgYWN0aXZlU2Vzc2lvbklkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCFhY3RpdmVJZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHByb3BlciBzZXNzaW9uIElEIGltbWVkaWF0ZWx5IGZvciB0aGUgbmV3IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgYWN0aXZlU2Vzc2lvbklkID0gYHNlc3Npb24tJHtnZW5lcmF0ZVVVSUQoKX1gO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdDb252OiBDb252ZXJzYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG5ld0lkLFxuICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IGFjdGl2ZVNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB0aXRsZTogY29udGVudC5zbGljZSgwLCAzMCkgfHwgJ05ldyBDaGF0JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldENvbnZlcnNhdGlvbnMocHJldiA9PiBbbmV3Q29udiwgLi4ucHJldl0pO1xuICAgICAgICAgICAgYWN0aXZlSWQgPSBuZXdJZDtcbiAgICAgICAgICAgIHNldEN1cnJlbnRDb252ZXJzYXRpb25JZChuZXdJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzTWVzc2FnZShhY3RpdmVJZCwgY29udGVudCwgZmlsZXMsIGFjdGl2ZVNlc3Npb25JZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHByb2Nlc3NNZXNzYWdlID0gYXN5bmMgKGNvbnZlcnNhdGlvbklkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgZmlsZXM6IEZpbGVBdHRhY2htZW50W10sIHNlc3Npb25JZE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSB1c2VyIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgdXNlck1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGZpbGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXBkYXRlIGNvbnZlcnNhdGlvbiB3aXRoIHVzZXIgbWVzc2FnZVxuICAgICAgICBzZXRDb252ZXJzYXRpb25zKHByZXYgPT4gcHJldi5tYXAoY29udiA9PiB7XG4gICAgICAgICAgICBpZiAoY29udi5pZCA9PT0gY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb252LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLmNvbnYubWVzc2FnZXMsIHVzZXJNZXNzYWdlXSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGNvbnYubWVzc2FnZXMubGVuZ3RoID09PSAwID8gKGNvbnRlbnQuc2xpY2UoMCwgMzApICsgKGNvbnRlbnQubGVuZ3RoID4gMzAgPyAnLi4uJyA6ICcnKSkgOiBjb252LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnY7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG5cbiAgICAgICAgbGV0IHJlc3VsdEl0ZW06IGFueSA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZUF0dGFjaG1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGVzJywgZmlsZUF0dGFjaG1lbnQuZmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgncXVlcnknLCBjb250ZW50KTtcblxuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnYgPSBjb252ZXJzYXRpb25zLmZpbmQoYyA9PiBjLmlkID09PSBjb252ZXJzYXRpb25JZCk7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIG92ZXJyaWRlIGlmIHByb3ZpZGVkIChmb3IgbmV3IGNoYXRzIHdoZXJlIHN0YXRlIG1pZ2h0IG5vdCBiZSB1cGRhdGVkIHlldCksIG90aGVyd2lzZSBmYWxsYmFjayB0byBzdGF0ZVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkVG9TZW5kID0gc2Vzc2lvbklkT3ZlcnJpZGUgfHwgKGN1cnJlbnRDb252ID8gY3VycmVudENvbnYuc2Vzc2lvbl9pZCA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uSWRUb1NlbmQpIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3Nlc3Npb25faWQnLCBzZXNzaW9uSWRUb1NlbmQpO1xuICAgICAgICAgICAgICAgIC8vIEFsc28gU2VuZCB1c2VyX2lkIGlmIG5lZWRlZCwgZGVmYXVsdGVkXG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCd1c2VyX2lkJywgJ2Fub255bW91cycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL244bi5zcnY5NzQyMjUuaHN0Z3IuY2xvdWQvd2ViaG9vay9hdXRvLXNhdmUtZmlsZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBsZXQgZGF0YTogYW55ID0ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCkgZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRW1wdHkgb3IgaW52YWxpZCBKU09OIHJlc3BvbnNlIGZyb20gTjhOXCIsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgcmVzcG9uc2UgdHlwZSBhbmQgc3RydWN0dXJlXG4gICAgICAgICAgICBsZXQgYWlDb250ZW50ID0gXCJQcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5LlwiO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGxpZnRlZCB0byBvdXRlciBzY29wZSBmb3IgZmluYWxseSBibG9ja1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgZGF0YTogaWYgYXJyYXksIHVzZSBmaXJzdCBpdGVtOyBlbHNlIHVzZSBkYXRhIG9iamVjdFxuICAgICAgICAgICAgcmVzdWx0SXRlbSA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhWzBdIDogZGF0YTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgU2VhcmNoIFJlc3BvbnNlIChWZWN0b3Igc2VhcmNoIG9mdGVuIHJldHVybnMgc2VhcmNoVHlwZT0ndmVjdG9yJyBhbmQgZmlsZXMgYXJyYXkpXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEl0ZW0uc2VhcmNoVHlwZSA9PT0gJ3ZlY3RvcicgfHwgKHJlc3VsdEl0ZW0uZmlsZXMgJiYgcmVzdWx0SXRlbS5maWxlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0SXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzOiByZXN1bHRJdGVtLmZpbGVzIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFpQ29udGVudCA9IHJlc3VsdEl0ZW0ubWVzc2FnZSB8fCBcIkhlcmUgYXJlIHRoZSBmaWxlcyBJIGZvdW5kIG1hdGNoaW5nIHlvdXIgcmVxdWVzdC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIERvY3VtZW50IEdlbmVyYXRpb25cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHRJdGVtLmFjdGlvbiA9PT0gJ2RvY3VtZW50X2dlbmVyYXRpb24nIHx8IHJlc3VsdEl0ZW0uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG9jdW1lbnRfZ2VuZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHRJdGVtXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFpQ29udGVudCA9IHJlc3VsdEl0ZW0ubWVzc2FnZSB8fCBcIkkgaGF2ZSBnZW5lcmF0ZWQgdGhlIGRvY3VtZW50IGZvciB5b3UuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBcIkFscmVhZHkgUHJvY2Vzc2VkXCIgVXBsb2FkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0SXRlbS5hbHJlYWR5UHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHRJdGVtXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFpQ29udGVudCA9IHJlc3VsdEl0ZW0ubWVzc2FnZSB8fCBcIlRoaXMgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFN0YW5kYXJkIFVwbG9hZCBTdWNjZXNzXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0SXRlbS5zdWNjZXNzICYmIHJlc3VsdEl0ZW0uZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1cGxvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0SXRlbVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhaUNvbnRlbnQgPSByZXN1bHRJdGVtLm1lc3NhZ2UgfHwgXCJGaWxlIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseS5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZ2VuZXJpYyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0SXRlbS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFpQ29udGVudCA9IHJlc3VsdEl0ZW0ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGV4dCAmJiAhcmVzdWx0SXRlbSkge1xuICAgICAgICAgICAgICAgIGFpQ29udGVudCA9IFwiUmVxdWVzdCByZWNlaXZlZCwgYnV0IG5vIHJlc3BvbnNlIGNvbnRlbnQgd2FzIHJldHVybmVkLlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2Vzc2lvbl9pZCBpZiByZXR1cm5lZFxuICAgICAgICAgICAgaWYgKHJlc3VsdEl0ZW0gJiYgKHJlc3VsdEl0ZW0uc2Vzc2lvbklkIHx8IHJlc3VsdEl0ZW0uY29udmVyc2F0aW9uPy5zZXNzaW9uX2lkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Nlc3Npb25JZCA9IHJlc3VsdEl0ZW0uc2Vzc2lvbklkIHx8IHJlc3VsdEl0ZW0uY29udmVyc2F0aW9uPy5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0lkID0gcmVzdWx0SXRlbS5jb252ZXJzYXRpb24/LmlkID8gcmVzdWx0SXRlbS5jb252ZXJzYXRpb24uaWQudG9TdHJpbmcoKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBzZXRDb252ZXJzYXRpb25zKHByZXYgPT4gcHJldi5tYXAoY29udiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb252LmlkID09PSBjb252ZXJzYXRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jb252LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IG5ld1Nlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbmV3SWQgfHwgY29udi5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udjtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3SWQgJiYgY29udmVyc2F0aW9uSWQgIT09IG5ld0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb252ZXJzYXRpb25JZChwcmV2ID0+IChwcmV2ID09PSBjb252ZXJzYXRpb25JZCA/IG5ld0lkIDogcHJldikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYWlNZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoRGF0ZS5ub3coKSArIDEpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2FpJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBhaUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VEYXRhXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXRDb252ZXJzYXRpb25zKHByZXYgPT4gcHJldi5tYXAoY29udiA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBwb3RlbnRpYWxseSBuZXcgSUQgaWYgd2UganVzdCB1cGRhdGVkIGl0LCBPUiBsb2dpYyB0byBzeW5jXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugc3RhdGUgdXBkYXRlIGlzIGFzeW5jLCAnY29udi5pZCcgaW4gdGhpcyBjeWNsZSBtaWdodCBwcmVzdW1hYmx5IHN0aWxsIGJlIG9sZCBJRCBpZiBtYXBwZWQgaW1tZWRpYXRlbHk/XG4gICAgICAgICAgICAgICAgLy8gTm8sIHdlIGFyZSBpbnNpZGUgYSBuZXcgU2V0U3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gVG8gYmUgc2FmZSwgd2UgbWF0Y2ggZWl0aGVyIElELlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gKHJlc3VsdEl0ZW0/LmNvbnZlcnNhdGlvbj8uaWQgJiYgY29udmVyc2F0aW9uSWQgIT09IHJlc3VsdEl0ZW0uY29udmVyc2F0aW9uLmlkLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0SXRlbS5jb252ZXJzYXRpb24uaWQudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnZlcnNhdGlvbklkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnYuaWQgPT09IHRhcmdldElkIHx8IGNvbnYuaWQgPT09IGNvbnZlcnNhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb252LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5jb252Lm1lc3NhZ2VzLCBhaU1lc3NhZ2VdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb252O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKERhdGUubm93KCkgKyAxKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHJvbGU6ICdhaScsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJTb3JyeSwgSSBlbmNvdW50ZXJlZCBhbiBlcnJvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIHNlcnZlci4gUGxlYXNlIHRyeSBhZ2Fpbi5cIixcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNldENvbnZlcnNhdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjb252ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udi5pZCA9PT0gY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLmNvbnYubWVzc2FnZXMsIGVycm9yTWVzc2FnZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnY7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gUmVmcmVzaCBjb252ZXJzYXRpb24gbGlzdCB0byB1cGRhdGUgdGl0bGVzL3RpbWVzdGFtcHNcbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIGNvcnJlY3QgSUQgKG5ldyByZWFsIG9uZSBvciBleGlzdGluZyBvbmUpIHRvIGVuc3VyZSBpdCBpcyBwcmVzZXJ2ZWQgaWYgbm90IHlldCBpbiBsaXN0XG4gICAgICAgICAgICBjb25zdCBmaW5hbElkID0gKHJlc3VsdEl0ZW0/LmNvbnZlcnNhdGlvbj8uaWQgJiYgY29udmVyc2F0aW9uSWQgIT09IHJlc3VsdEl0ZW0uY29udmVyc2F0aW9uLmlkLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgPyByZXN1bHRJdGVtLmNvbnZlcnNhdGlvbi5pZC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgOiBjb252ZXJzYXRpb25JZDtcbiAgICAgICAgICAgIGZldGNoQ29udmVyc2F0aW9ucyhmaW5hbElkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVSZW5hbWVDb252ZXJzYXRpb24gPSBhc3luYyAoaWQ6IHN0cmluZywgbmV3VGl0bGU6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZVxuICAgICAgICBzZXRDb252ZXJzYXRpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PlxuICAgICAgICAgICAgYy5pZCA9PT0gaWQgPyB7IC4uLmMsIHRpdGxlOiBuZXdUaXRsZSB9IDogY1xuICAgICAgICApKTtcblxuICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSBjb252ZXJzYXRpb25zLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChjb252ZXJzYXRpb24gJiYgY29udmVyc2F0aW9uLnNlc3Npb25faWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9uOG4uc3J2OTc0MjI1LmhzdGdyLmNsb3VkL3dlYmhvb2svOThiMjExZTgtMTMyNS00ODY3LWE5MzctOWJkYWEwZjE0MGQyL3JlbmFtZS1jb252ZXJzYXRpb24vJHtjb252ZXJzYXRpb24uc2Vzc2lvbl9pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdGl0bGU6IG5ld1RpdGxlIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0NvbnZlcnNhdGlvbiByZW5hbWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGBFcnJvcjogJHtkYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gcmVuYW1lIGNvbnZlcnNhdGlvbid9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElkZWFsbHkgcmV2ZXJ0IG9wdGltaXN0aWMgdXBkYXRlIGhlcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5hbWUgY29udmVyc2F0aW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdFcnJvcjogRmFpbGVkIHRvIHJlbmFtZSBjb252ZXJzYXRpb24uIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlRGVsZXRlQ29udmVyc2F0aW9uID0gYXN5bmMgKGlkOiBzdHJpbmcsIGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKCFjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgY29udmVyc2F0aW9uPycpKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gY29udmVyc2F0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gaWQpO1xuXG4gICAgICAgIC8vIE9wdGltaXN0aWMgZGVsZXRlXG4gICAgICAgIHNldENvbnZlcnNhdGlvbnMocHJldiA9PiBwcmV2LmZpbHRlcihjID0+IGMuaWQgIT09IGlkKSk7XG4gICAgICAgIGlmIChjdXJyZW50Q29udmVyc2F0aW9uSWQgPT09IGlkKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50Q29udmVyc2F0aW9uSWQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udmVyc2F0aW9uICYmIGNvbnZlcnNhdGlvbi5zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vbjhuLnNydjk3NDIyNS5oc3Rnci5jbG91ZC93ZWJob29rLzk4YjIxMWU4LTEzMjUtNDg2Ny1hOTM3LTliZGFhMGYxNDBkMi9kZWxldGUtY29udmVyc2F0aW9uLyR7Y29udmVyc2F0aW9uLnNlc3Npb25faWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoZGF0YS5tZXNzYWdlIHx8ICdDb252ZXJzYXRpb24gZGVsZXRlZCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGBFcnJvcjogJHtkYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gZGVsZXRlIGNvbnZlcnNhdGlvbid9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCByZXZlcnQgc3RhdGUgaWYgZmFpbGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGNvbnZlcnNhdGlvbicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBhbGVydCgnRXJyb3I6IEZhaWxlZCB0byBkZWxldGUgY29udmVyc2F0aW9uLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBoLXNjcmVlbiBiZy1bdmFyKC0tYmFja2dyb3VuZCldIHRleHQtW3ZhcigtLWZvcmVncm91bmQpXSBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgIDxTaWRlYmFyXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9ucz17Y29udmVyc2F0aW9uc31cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udmVyc2F0aW9uSWQ9e2N1cnJlbnRDb252ZXJzYXRpb25JZH1cbiAgICAgICAgICAgICAgICBvblNlbGVjdENvbnZlcnNhdGlvbj17c2V0Q3VycmVudENvbnZlcnNhdGlvbklkfVxuICAgICAgICAgICAgICAgIG9uTmV3Q2hhdD17Y3JlYXRlTmV3Q29udmVyc2F0aW9ufVxuICAgICAgICAgICAgICAgIG9uUmVuYW1lQ29udmVyc2F0aW9uPXtoYW5kbGVSZW5hbWVDb252ZXJzYXRpb259XG4gICAgICAgICAgICAgICAgb25EZWxldGVDb252ZXJzYXRpb249e2hhbmRsZURlbGV0ZUNvbnZlcnNhdGlvbn1cbiAgICAgICAgICAgICAgICBpc09wZW49e3NpZGViYXJPcGVufVxuICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldFNpZGViYXJPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIGZsZXggZmxleC1jb2wgaC1mdWxsIHJlbGF0aXZlIHctZnVsbFwiPlxuICAgICAgICAgICAgICAgIHsvKiBNb2JpbGUgSGVhZGVyICovfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWQ6aGlkZGVuIGZsZXggaXRlbXMtY2VudGVyIHAtNCBib3JkZXItYiBib3JkZXItW3ZhcigtLWJvcmRlci1jb2xvcildIGJnLVt2YXIoLS1iYWNrZ3JvdW5kKV1cIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2lkZWJhck9wZW4odHJ1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgLW1sLTIgdGV4dC1ncmF5LTQwMCBob3Zlcjp0ZXh0LXdoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUgY2xhc3NOYW1lPVwidy02IGgtNlwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJtbC0yIGZvbnQtc2VtaWJvbGRcIj5BSSBBc3Npc3RhbnQ8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICB7LyogTWFpbiBDaGF0IEFyZWEgKi99XG4gICAgICAgICAgICAgICAgPE1lc3NhZ2VMaXN0XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzPXtnZXRDdXJyZW50TWVzc2FnZXMoKX1cbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkaW5nPXtpc0xvYWRpbmd9XG4gICAgICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgICAgIHsvKiBJbnB1dCBBcmVhICovfVxuICAgICAgICAgICAgICAgIDxJbnB1dEFyZWFcbiAgICAgICAgICAgICAgICAgICAgb25TZW5kTWVzc2FnZT17aGFuZGxlU2VuZE1lc3NhZ2V9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc0xvYWRpbmd9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJNZW51IiwiU2lkZWJhciIsIk1lc3NhZ2VMaXN0IiwiSW5wdXRBcmVhIiwiQ2hhdEludGVyZmFjZSIsImNvbnZlcnNhdGlvbnMiLCJzZXRDb252ZXJzYXRpb25zIiwiY3VycmVudENvbnZlcnNhdGlvbklkIiwic2V0Q3VycmVudENvbnZlcnNhdGlvbklkIiwic2lkZWJhck9wZW4iLCJzZXRTaWRlYmFyT3BlbiIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImlzSW5pdGlhbExvYWQiLCJ1c2VSZWYiLCJnZW5lcmF0ZVVVSUQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwicmVwbGFjZSIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsInYiLCJ0b1N0cmluZyIsImZldGNoQ29udmVyc2F0aW9ucyIsInVzZUNhbGxiYWNrIiwic3BlY2lmaWNJZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInRleHQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwic3VjY2VzcyIsIkFycmF5IiwiaXNBcnJheSIsInByZXYiLCJleGlzdGluZ01hcCIsIk1hcCIsImZvckVhY2giLCJzZXQiLCJpZCIsInNlc3Npb25faWQiLCJtYXBwZWQiLCJtYXAiLCJiYWNrZW5kSWQiLCJleGlzdGluZyIsImdldCIsInRpdGxlIiwibWVzc2FnZXMiLCJjcmVhdGVkQXQiLCJEYXRlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRBdCIsImxhc3RfYWN0aXZpdHkiLCJpZFRvUHJlc2VydmUiLCJpc1ByZXNlbnQiLCJzb21lIiwiY3VycmVudEFjdGl2ZSIsImZpbmQiLCJjdXJyZW50IiwibGVuZ3RoIiwiZXJyb3IiLCJjb252ZXJzYXRpb24iLCJsb2FkQ29udmVyc2F0aW9uSGlzdG9yeSIsInNlc3Npb25JZCIsImNvbnZlcnNhdGlvbklkIiwibWFwcGVkTWVzc2FnZXMiLCJtc2ciLCJpbmRleCIsIm1lc3NhZ2VEYXRhIiwiYWN0aW9uIiwiZmlsZXMiLCJ0eXBlIiwiZm91bmQiLCJjb3VudCIsInJlc3VsdHNfY291bnQiLCJtZXNzYWdlIiwiY29udGVudCIsImF2Z19zaW1pbGFyaXR5Iiwic2VhcmNoQ3JpdGVyaWEiLCJzZWFyY2hfY3JpdGVyaWEiLCJkb2N1bWVudF9jb250ZW50IiwiZmlsZV9pbmZvIiwiZG9jdW1lbnQiLCJuYW1lIiwibm93Iiwicm9sZSIsInRpbWVzdGFtcCIsImNvbnYiLCJnZXRDdXJyZW50TWVzc2FnZXMiLCJjcmVhdGVOZXdDb252ZXJzYXRpb24iLCJoYW5kbGVTZW5kTWVzc2FnZSIsImFjdGl2ZUlkIiwiYWN0aXZlU2Vzc2lvbklkIiwidW5kZWZpbmVkIiwibmV3SWQiLCJuZXdDb252Iiwic2xpY2UiLCJwcm9jZXNzTWVzc2FnZSIsInNlc3Npb25JZE92ZXJyaWRlIiwidXNlck1lc3NhZ2UiLCJyZXN1bHRJdGVtIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImZpbGVBdHRhY2htZW50IiwiYXBwZW5kIiwiZmlsZSIsImN1cnJlbnRDb252Iiwic2Vzc2lvbklkVG9TZW5kIiwibWV0aG9kIiwiYm9keSIsIkVycm9yIiwic3RhdHVzVGV4dCIsImFpQ29udGVudCIsInNlYXJjaFR5cGUiLCJhbHJlYWR5UHJvY2Vzc2VkIiwibmV3U2Vzc2lvbklkIiwiYWlNZXNzYWdlIiwidGFyZ2V0SWQiLCJlcnJvck1lc3NhZ2UiLCJmaW5hbElkIiwiaGFuZGxlUmVuYW1lQ29udmVyc2F0aW9uIiwibmV3VGl0bGUiLCJoZWFkZXJzIiwic3RyaW5naWZ5IiwianNvbiIsImFsZXJ0IiwiaGFuZGxlRGVsZXRlQ29udmVyc2F0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwiY29uZmlybSIsImZpbHRlciIsImRpdiIsImNsYXNzTmFtZSIsIm9uU2VsZWN0Q29udmVyc2F0aW9uIiwib25OZXdDaGF0Iiwib25SZW5hbWVDb252ZXJzYXRpb24iLCJvbkRlbGV0ZUNvbnZlcnNhdGlvbiIsImlzT3BlbiIsIm9uQ2xvc2UiLCJidXR0b24iLCJvbkNsaWNrIiwic3BhbiIsIm9uU2VuZE1lc3NhZ2UiLCJkaXNhYmxlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ChatInterface.tsx\n"));

/***/ })

});